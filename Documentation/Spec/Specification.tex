\documentclass[a4paper,12pt]{article}
\addtolength{\oddsidemargin}{-1.cm}
\addtolength{\textwidth}{2cm}
\addtolength{\topmargin}{-2cm}
\addtolength{\textheight}{3.5cm}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\makeindex

\usepackage{longtable}
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{hyperref}
\usepackage{verbatim}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
}


% define the title
\author{Whoosh Division}
\title{OcuViz - EpiUse Labs}
\begin{document}
\setlength{\parskip}{6pt}

% generates the title
\begin{titlepage}

\begin{center}
% Upper part of the page       
\includegraphics[width=1\textwidth]{./images/up-logo.jpg}\\[0.4cm]    
\textsc{\LARGE Department of Computer Science}\\[1.5cm]
\textsc{\Large Whoosh Division}\\[0.3cm]
% Title
\HRule \\[0.4cm]
{ \huge \bfseries OcuViz - EpiUse Labs}\\[0.4cm]
{ \huge Software Requirements Specification\\[0.4cm]and Technology Neutral Process Design }\\[0.4cm]
\HRule \\[0.4cm]
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Vukile {Langa}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{} \\
u14035449 
\end{flushright}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Wynand Hugo Meiring
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{} \\
u13230795  
\end{flushright}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Nontokozo Hlastwayo
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{} \\
u14414555
\end{flushright}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Gerome Schutte
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{} \\
u12031519
\end{flushright}
\end{minipage}
\vfill

{\large \today}
\end{center}
\end{titlepage}
\footnotesize
\normalsize

%
%	Table of Contents
%

\tableofcontents
\newpage

%
%	Document
%
%	The detailed functional requirements around individual use cases will be done iteratively in the
% 	context of agile software development, i.e. the subsequent documentation submissions will include the
% 	detailed functional requirements, application design, user documentation and test documentation for
%	those use cases which have been completed since the last demo.
%

\section{Vision}

	% To-do
	OcuViz is a platform for creating rich visual representations of otherwise unintuitive data by using the power of virtual reality visualisation. It aims to address the time consuming task of working with 3D scenes and make it simple, by providing a format for specifying scenes that is concise, optimised for integration with pluggable data, and to be targeted at being easily usable by anyone with even the slightest development experience.\\\\
	OcuViz would typically be deployed in research, data-auditing and demonstration environments, where visualisations may be used as a medium to bring data to life, for example, describing a scene that gives viewers an interactive walk-around view of a solar cataclysm rather than simply listing numbers representing objects and scale, or allowing viewers to encounter the world from the point of view of a tiny animal, or giving demonstrators the power to transport an audience to a previously unseen location.
	
\section{Background}

	EPI-Use Labs provides products aimed at getting the most out of data. The business prides itself in deploying products which allow users to sync, manipulate, extract and report various forms of data, whether through on-site or cloud-based solutions. The OcuViz project is a natural evolution of this focus. OcuViz enriches the data-reporting process for in-house developers at EPI-Use Labs and business clients alike, by adding new visual and interactive dimensions throughout their project life-cycles, whether used in product development as a tool to interact with test and debugging data, or as a value added feature in a complete solution.

\newpage

\section{Architecture Requirements}

\subsection{Access Channel Requirements}
	
	The system should be accessible via a desktop client, with mobile clients specified as optional, but most likely not feasible due to the hardware requirements of graphics processing. The target platform is Windows x64, and as such a Windows x64 client should be provided in the form of a .exe file, complete with .exe install file.

\subsection{Quality Requirements}
	
	\subsubsection{Performance}
	
		Stringent performance requirements are necessary, not only for novelty purposes, but due to the introduction of virtual reality. In order for visualisations running in virtual reality not to cause motion sickness in the viewer, the following minimum requirements need to be met:
		
		\begin{itemize}
			\item Visualisations produced must run at a constant framerate of 75fps or more.
			\item Overall system latency between user input and display must be kept below a maximum of 20ms.
		\end{itemize}
	
	\subsubsection{Reliability}
	
		\begin{itemize}
			\item Since input data and scene descriptor files may optionally in large part be user- or externally generated, faulty input data and scene descriptor files must be detected and reported without system crash.
			\item All expected user inputs for each visualisation must be clearly defined. Where an input is not declared as "expected", it must have no effect.
			\item The results of rendering a visualisation from a scene descriptor and input data file must be predictable and repeatable. 
			\item Objects in a scene created via the scene editor must have the same properties in the actual visualisation as specified the scene editor.
			\item All visible objects specified in the scene descriptor file or placed via the scene editor must be rendered in the visualisation.
		\end{itemize}
		
	\subsubsection{Scalability}
	
		\begin{itemize}
			\item The system must be developed using technologies which are operating system neutral. Windows x64 is specified as the priority target platform, but the client may in future choose to port the system to another operating system, and must be able to do so without having to rewrite system components.
		\end{itemize}
	
	\subsubsection{Flexibility}
	
		\begin{itemize}
			\item Visualisations must be renderable using either "hard-coded" objects fully specified in a scene descriptor file, or object blueprints specified in a scene descriptor file with "variable" object properties that may be read from an input data file.
			\item Input data files must be pluggable, provided they contain valid input data as required by the object blueprints listed in the scene descriptor file.
		\end{itemize}
		
	\subsubsection{Maintainability}
	
		\begin{itemize}
			\item Version control must be used throughout the development process to create a centralised point auditing and review of code changes and simple rolling back to working system versions.
			\item System components must be designed to be modular, following a separation of concerns approach, in order to ease pin-pointing of system errors and swapping out of existing system modules.
		\end{itemize}
		
	\subsubsection{Cost}
	
		\begin{itemize}
			\item The client has not budgeted for additional technologies or hardware, and as such, all technologies used in development must be free for use.
		\end{itemize}
	
	\subsubsection{Usability}
	
		\begin{itemize}
			\item  A complete manual must be provided describing the valid format and possible inputs of a scene descriptor file.
			\item Only two creation contexts for visualisations are specified: importing a scene descriptor and optional input data files, and using the scene editor. Within these contexts, each use case must have a single point of access to contribute to use cases being intuitive and predictable.
			\item A running visualisation must have clearly visible access to visualisation variable controls, such as viewer scale and position. 
		\end{itemize}

\newpage

\subsection{Architecture Constraints}

	\subsubsection{Required Technologies}
		
		\begin{itemize}
			\item \textbf{Software:}
				\begin{itemize}
					\item Microsoft Windows 7 SP1 or newer x64 version operating system.
				\end{itemize}
			\item \textbf{Hardware:}
				\begin{itemize}
					\item Oculus Rift Virtual Reality Headset
					\item Due to the processing requirements of virtual reality and the Oculus Rift, a host machine is required with:
						\begin{itemize}
							\item Graphics: NVIDIA GTX 970 / AMD 290 equivalent or greater
							\item Processor: Intel i5-4590 equivalent or greater
							\item 8GB+ RAM
							\item HDMI 1.3 video output port
							\item 2x USB 3.0 ports
						\end{itemize}
				\end{itemize}
		\end{itemize}
	
	\subsubsection{Architectural Strategies}
		
		\begin{itemize}
			\item \textbf{Performance Strategies:}\\
				To meet the performance demand of graphics processing, it is suggested that an increase in processing power be implemented. Since graphical object creation is expensive, and often multiple similar objects are rendered in the same scene, resource re-use is to be implemented in the form of object pooling and caching.
			\item \textbf{Reliability Strategies:}\\
				In order to maintain reliable system behaviour, fault detection mechanisms must be put in place. Exception communication is to be used throughout the rendering process in the event of invalid input, with self-testing service providers ensuring the validity of input arguments and generated output. System based faults must be prevented by the use of a testing framework and test-driven development approaches.
			\item \textbf{Flexibility Strategies:}\\
				Multiple forms of flexibility strategies must be employed:
				
				\begin{itemize}
					\item Process Flexibility:
						\begin{itemize}
							\item A dedicated workflow controller must be responsible for overseeing the entire object parsing process.
							\item Each system module must employ responsibility localization.
						\end{itemize}
					\item Service Provider Flexibility:
						\begin{itemize}
							\item All system modules and service providers must be contracts based.
							\item Objects of various predefined types must be created using abstract factories.
							\item Dependency injection must be employed across the system.
						\end{itemize}
					\item Flexibility Support:
						\begin{itemize}
							\item Automated builds must be run on each code repository change using a continuous integration server.
							\item Automated testing of all use cases must be run on each automated build.
						\end{itemize}
				\end{itemize}
		\end{itemize}

\section{Architecture design?}
	Is this needed?? Subsections include: architectural tactics, architectural components addressing architectural responsibilities, infrastructure, concepts and contraints for application components

\newpage
%
%	End of Architectural Requirements
%




\section{Initial Design}  % proposed software architecture (this may evolve over the project)

	% To-do

\newpage
%
%	End of Initial Design
%
\end{document}
